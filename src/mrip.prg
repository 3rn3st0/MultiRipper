/*                                   ›  ﬁ
                                 ‹   ﬁ  ﬁ ›
                                   ›  ›  ›ﬁ
                                 ‹ ﬁ  ﬁ ﬁ › ‹
                                  ﬂ‹ﬂﬂﬂﬂﬂﬂ‹ﬁ               ‹
                                  ﬁ  ƒÕÕƒ  ›              ﬁ››
                                 ﬁ‹‹‹‹ƒƒ‹‹‹‹›             ﬁ ›
                                 ﬁ›‹‹ﬁﬂﬂ›‹‹ﬁ›             › ›‹‹
                                 ››€ﬂﬁ  ›ﬂ€ﬁﬁ            ﬁ ﬁ ƒƒ›
                   ‹ ‹ ‹ ‹       ›ﬂ‹‹›  ﬁ‹‹ﬂﬁ           ‹ﬂ   ƒƒ›
  ‹ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬁ ≥ ≥ ≥ ›ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬁ    ›ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ‹
 ﬁ ‹ﬂ ﬂ ﬂ         ﬁ ≥ ≥ ≥ ›         ›    ﬁ                             ﬂ ﬂ ﬂ‹ ›
 ›ﬁ                ﬂﬁ ≥ ≥ ›         ›    ﬁ                                   ›ﬁ
 ››                  ﬂﬁ ›ﬂ         ﬁ ›    ›                                  ﬁﬁ
 ›                     ﬂ            ›ﬁ › ﬁ                                    ﬁ
 ››                                 ﬁ ﬂ  ›                                   ﬁﬁ
 ›                                   ﬂ‹‹ﬂ                                     ﬁ
 ›                                               ∞                            ﬁ
 ›                                      ∞       ∞±                            ﬁ
 ›                                     ∞±       ±≤       ‹±                   ﬁ
 ›                                     ±≤       ≤€       ±ﬂ                   ﬁ
 ›                                     ≤€       €€                            ﬁ
 ›                €€ﬂ€€ﬂ€€€€‹ €€ €€€€€ €€   ﬂ ﬂﬂ€€ﬂﬂﬂ ﬂ  €€                   ﬁ
 ›                €€ €€ €€€€€ €€ €€€€€ €€       €€       €€                   ﬁ
 ›                €€ €€ €€€€€ €€ €€€€€ €€ €€€€€ €€ €€€€€ €€                   ﬁ
 ›                €€ €≤ €€€€€ ﬂ€‹€€€€≤ ﬂ€‹€€€€ﬂ ﬂ€‹€€€€ﬂ €≤                   ﬁ
 ›     ‹  ‹  ‹ ‹‹‹€≤ ≤± €€€€≤‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹≤±‹‹‹‹ ‹  ‹  ‹       ﬁ
 ›                ≤± ±∞                                  ±∞                   ﬁ
 ›                ±∞ ∞   ‹±                              ∞                    ﬁ
 ›                ∞      ±ﬂ                                                   ﬁ
 ›                                                                            ﬁ
 ›             €€ﬂ€€€€€‹ €€ €€ﬂ€€€€‹ €€ﬂ€€€€‹ ‹€ﬂﬂﬂﬂ ﬂ €€ﬂ€€€€€‹              ﬁ
 ›             €€‹€€€€€ﬂ €€ €€ €€€€€ €€ €€€€€ €€ﬂﬂ     €€‹€€€€€ﬂ              ﬁ
 ›             €€ €€€€€€ €€ €€ €€€€€ €€ €€€€€ €€ €€€€€ €€ €€€€€€              ﬁ
 ›             €€ €€€€€€ €€ €€‹€€€€ﬂ €€‹€€€€ﬂ ﬂ€‹€€€€ﬂ €€ €€€€€€ iAN/TWT      ﬁ
 ›  ‹  ‹  ‹ ‹‹‹€€ ﬂ€€€€≤‹€≤‹€≤‹‹‹‹‹‹‹€≤‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹€€ ﬂ€€€€≤‹‹‹ ‹  ‹  ‹   ﬁ
 ›             €≤        ≤± ≤±       ≤±                                       ﬁ
 ›             ≤±        ±∞ ±∞       ±∞                                       ﬁ
 ›             ±∞        ∞  ∞        ∞                                        ﬁ
 ›             ∞                                                              ﬁ
 ››                                                                          ﬁﬁ
 ›                                                                            ﬁ
 ››                                                                          ﬁﬁ
 ›ﬁ                                                                          ›ﬁ
 ﬁ ﬂ‹ ‹ ‹                                                              ‹ ‹ ‹ﬂ ›
  ﬂ‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹ﬂ
*/


#include "mripper.ch"

STATIC aStaticone := {}

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE ripper()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL hin, bytesin:=1, filepos:=0, filelen:=0, writing:=.F.
LOCAL hout, cbuff ,match, ln, pattern:=space(10), patlen, Pat_PTR, name:=""
LOCAL SKIPBYTES:=0, userbrk:=.F., lenout, Desc_patt:="", patt, ext, nWarning
LOCAL nTime := SECONDS(), nRows, nCols

ASTATICONE := {}

//ARRCHOICE
AADD(ASTATICONE, {}                                             )
//NAMECOUNT
AADD(ASTATICONE, 0                                              )
//OLDSCREEN
AADD(ASTATICONE, 25                                             )
//PROCESS_ALL
AADD(ASTATICONE, 0                                              )
//BIG_DONE
AADD(ASTATICONE, "⁄ƒƒø ⁄ƒƒƒø⁄ƒƒƒø⁄ƒƒƒø ⁄ƒø;"+;
                 "≥  ¿ø≥ ≥ ≥≥   ≥≥ ≥ ≥ ≥ ≥;"+;
                 "≥ ≥ ≥≥   ≥≥ ≥ ≥≥ ⁄ƒ¥ ≥ ≥;"+;
                 "≥   ≥≥   ≥≥ ≥ ≥≥   ≥ ≥ ≥;"+;
                 "≥  ⁄Ÿ≥   ≥≥ ≥ ≥≥   ≥ √ƒ¥;"+;
                 "¿ƒƒŸ ¿ƒƒƒŸ¿ƒ¡ƒŸ¿ƒƒƒŸ ¿ƒŸ;"                    )
//BIG_WARN
AADD(ASTATICONE, "  ≥ ≥⁄ƒø⁄ƒø⁄ƒø≥⁄ƒø⁄ƒ   ;"+;
                 "  ≥≥≥≥ƒ¥≥⁄Ÿ≥ ≥≥≥ ≥≥ ø  ;"+;
                 "  ¿¡Ÿ≥ ≥≥¿ø≥ ≥≥≥ ≥¿ƒŸ  ; ;"                   )
//BIG_ERROR
AADD(ASTATICONE, "  ⁄ƒƒø ⁄ƒƒø ⁄ƒƒø ⁄ƒƒø ⁄ƒƒø ;"+;
                 "  ≥    ≥  ≥ ≥  ≥ ≥  ≥ ≥  ≥ ;"+;
                 "  √ƒ   ≥ƒ¬Ÿ ≥ƒ¬Ÿ ≥  ≥ ≥ƒ¬Ÿ ;"+;
                 "  ¿ƒƒŸ ¡ ¿Ÿ ¡ ¿Ÿ ¿ƒƒŸ ¡ ¿Ÿ ; ;"               )
//BIG_BREAK
AADD(ASTATICONE, "⁄   ¬ƒƒø⁄ƒƒø⁄ƒƒø⁄ ⁄  ;"+;
                 "≥ƒƒø≥  Ÿ≥  ≥   ≥≥⁄Ÿ  ;"+;
                 "≥  ≥≥   ≥ƒƒŸ⁄ƒƒ≥√¡ƒø ;"+;
                 "¿ƒƒŸ¡ƒ  ¿ƒƒŸ¿ƒƒ¡¿  ¿ ;"                       )
//NACTUAL
AADD(ASTATICONE, 1                                              )
//NOFFSET
AADD(ASTATICONE, 1                                              )
//PARM
AADD(ASTATICONE, ""                                             )
//EXTPATH
AADD(ASTATICONE, ""                                             )
//AFILE2EXT
//Struttura file con informazioni file
// [1] = Posizione attuale
// [2] = Array file
AADD(ASTATICONE, {}                                             )
//FCHECKMORE
AADD(ASTATICONE, .T.                                            )
//FBATCH
AADD(ASTATICONE, .F.                                            )
//FFLUSH
AADD(ASTATICONE, .T.                                            )
//PTRFILENAME
AADD(ASTATICONE, 1                                              )
//FALSEALARM
AADD(ASTATICONE, 0                                              )
//START_POS
AADD(ASTATICONE, 0                                              )
//ALTMEM
AADD(ASTATICONE, .T.                                            )
//ISTHESAME
AADD(ASTATICONE, .F.                                            )
//MINI_LOGO
/*
AADD(ASTATICONE, "                 ‹         ;"+;
                 "  ‹‹‹‹‹‹  ‹‹‹‹‹  ‹ ‹‹‹‹‹   ;"+;
                 "  € € €€€ € €€€€ € € €€€€  ;"+;
                 "  € € €€€ €ﬂ€€€‹ € € €€€€  ;"+;
                 "  € € €€€ € €€€€ € €€€€€ﬂ  ;"+;
                 "  € € €€€ € ﬂ€€€ € €       ;"+;
                 "  € ›     ›      › › "+RIPVERSION+"  ;"+;
                 "  ›                        ;"  )
*/
AADD(ASTATICONE, "                 ‹         ;"+;
                 "  ‹‹‹‹‹‹  ‹‹‹‹‹  ‹ ‹‹‹‹‹   ;"+;
                 "  € € €€€ € €€€€ € € €€€€  ;"+;
                 "  € € €€€ €ﬂ€€€‹ € € €€€€  ;"+;
                 "  € € €€€ € €€€€ € €€€€€ﬂ  ;"+;
                 "  € € €€€ € ﬂ€€€ € €       ;"+;
                 "  €       €      € € "+padl(RIPVERSION,5)+" ;"+;
                 "                           ;"  )

//OLDBLINK
AADD(ASTATICONE, .t.                                            )
//OUTDEBUG
AADD(ASTATICONE, 0                                              )
//OLDPTR
AADD(ASTATICONE, ""                                             )
//HLOG
AADD(ASTATICONE, 0                                              )
//ARRLIBS
AADD(ASTATICONE,{"The Coexistence XLink v2.02", ;     //1
                 " The Coexistence XLink 1.0 ", ;     //2
                 "ACME Virtual FileSystem 1.0", ;     //3
                 "      Future Crew Lib      ", ;     //4
                 "    RealTech Lib (EXE)     ", ;     //5
                 "     Psychic Link FLIB     ", ;     //6
                 "  ElectroMotive Force Lib  ", ;     //7
                 " Pelusa Resource Compiler  ", ;     //8
                 "    RealTech Lib (DAT)     ", ;     //9
                 "       LucasArts GOB       ", ;     //10
                 "      iD Software WAD      ", ;     //11
                 "   Cascada Resource File   ", ;     //12
                 "        Iguana Lib         ", ;     //13
                 " 3dRealms GRP (Duke Nukem) ", ;     //14
                 "        Japotek Lib        ", ;     //15
                 "Digital Underground DFMAKE ", ;     //16
                 " CHAMP Programming Library ", ;     //17
                 " Datalib file v1.0 Library ", ;     //18
                 "  Deathstar  CLAUDIA DEMO  ", ;     //19
                 "         QUAKE MAP         ", ;     //20
                 "           CHASM           ", ;     //21
                 "      Frost Installer      ", ;     //22
                 "    COYOTE File Library    ", ;     //23
                 "    (B)ZIP File Library    ", ;     //24
                 "    Fusion File Library    ", ;     //25
                 "  PRIMITIVE File Library   ", ;     //26
                 "     TOUR File Library     ", ;     //27
                 "  ANONYMOUS File Library   ", ;     //28
                 "    BAZAR File Library     ", ;     //29
                 "    LOUIS File Library     ", ;     //30
                 "   JAPOTEK JPK  Library    ", ;     //31
                 "       LABN Library        ", ;     //32
                 "         CRYO LIB          "    })  //33
//STRINGPOS
AADD(ASTATICONE, 0                                              )
//MULTIFONT
AADD(ASTATICONE, .T.                                            )
//XORPATTERN
AADD(ASTATICONE, 0                                              )
//FASTSCAN
AADD(ASTATICONE, ""                                             )
//FBATCHFAST
AADD(ASTATICONE, .F.                                            )
//TOTCOUNTER
AADD(ASTATICONE, 0                                              )
//SKIPIFLIB
AADD(ASTATICONE, .F.                                            )
//BUFLEN
//AADD(ASTATICONE, 4096                                           )
AADD(ASTATICONE, 4096*8                                         )
//FILEMASK
AADD(ASTATICONE, {}                                             )
//RECOURSE
AADD(ASTATICONE, .F.                                            )
//LOCCOUNTER
AADD(ASTATICONE, 0                                              )
//EXPAND
AADD(ASTATICONE, .F.                                            )
//PACKLIST
AADD(ASTATICONE, {}                                             )
//FILELIST
AADD(ASTATICONE, {}                                             )
//AFILE2DEL
AADD(ASTATICONE, {}                                             )
//DEHACKSTOP
AADD(ASTATICONE, .F.                                            )
//HACKSTOPERASE
AADD(ASTATICONE, .T.                                            )
//GENERICDUMP
AADD(ASTATICONE, .F.                                            )
//GENPATH
AADD(ASTATICONE, {}                                             )
//MASTERFORMAT
AADD(ASTATICONE, {}                                             )
//ARESOURCE
AADD(ASTATICONE, {}                                             )
//DELPHIVERBOSE
AADD(ASTATICONE, .F.                                            )
//DELPHISOURCE
AADD(ASTATICONE, {}                                             )
//DELPHIMETHODS
AADD(ASTATICONE, .F.                                            )
//REGISTRATION
AADD(ASTATICONE, ""                                             )
//SERIAL
AADD(ASTATICONE, ""                                             )
//SERTYPE
//AADD(ASTATICONE, MRIPPER_SHAREWARE                              )
AADD(ASTATICONE, ""                                             )
//TWEAKED80X50
AADD(ASTATICONE, .F.                                            )
//INTROOUT
AADD(ASTATICONE, .F.                                            )

//                            12345678901234567890123456789012345678901234567890
//                             Pattern  16ch.  Description 26chars        EXT OFFSET˝
//                            |--------------| |------------------------| |-| |
AADD(MASTERFORMAT,  "FORM"+chr(0)+"           ≥Interleaved Bitmap        ≥LBM≥0")
AADD(MASTERFORMAT,           "GIF8            ≥CompuServe GIF (87a/89a)  ≥GIF≥0")
AADD(MASTERFORMAT,           "0x0A0501        ≥ZSoft PCX 3.0             ≥PCX≥0")
AADD(MASTERFORMAT,           "RIX3            ≥ColoRix Picture           ≥SCX≥0")
AADD(MASTERFORMAT,  "âPNG"+CRLFEOFLF+"        ≥Portable Network Graphic  ≥PNG≥0")
AADD(MASTERFORMAT,  "mhwanh"+chr(0)+"        ≥HSI Raw Picture [Alchemy] ≥RAW≥0")
AADD(MASTERFORMAT,  "ˇÿˇ‡"+chr(0)+"JFIF      ≥JPEG Picture              ≥JPG≥0")
AADD(MASTERFORMAT,  "II*"+chr(0)+"            ≥Intel TIFF Picture        ≥TIF≥0")
AADD(MASTERFORMAT,           "BM              ≥Windows Bitmap            ≥BMP≥0")
AADD(MASTERFORMAT,   "Y¶jï"+_2_CH0+"          ≥Sun Raster Picture        ≥RAS≥0")
AADD(MASTERFORMAT,              TGA1PATT+"    ≥Targa (Uncomp. 256 Colors)≥TGA≥0")
AADD(MASTERFORMAT,              TGA2PATT+"    ≥Targa (Uncomp. True Color)≥TGA≥0")
AADD(MASTERFORMAT,           "MDRAW           ≥Arkham MasterDraw         ≥MTR≥0")
AADD(MASTERFORMAT,           "GPH            ≥Megatech's Graphic file   ≥GPH≥0")
AADD(MASTERFORMAT,    REPLICATE(CHR(255),16)+"≥16Bits Font (80x25)       ≥F16≥3504")   // chr(224)*nbits
AADD(MASTERFORMAT,    REPLICATE(CHR(255), 8)+"        ≥8 Bits Font (80x50)       ≥F8 ≥1752")
AADD(MASTERFORMAT, chr(3)+_3_CH0+"==          ≥Autodesk 3D Studio Mesh   ≥3DS≥12")
AADD(MASTERFORMAT,           "0x11AF          ≥Autodesk FLI Animation    ≥FLI≥4")
AADD(MASTERFORMAT,           "0x12AF          ≥Autodesk FLC Animation    ≥FLC≥4")
AADD(MASTERFORMAT,           "AVI LIST        ≥AVI Animation             ≥AVI≥8")
AADD(MASTERFORMAT,      MPEGPATT +"           ≥MPEG Animation            ≥MPG≥0")
AADD(MASTERFORMAT,           "0x47430002      ≥Cobra Mission CG          ≥CG ≥0")
AADD(MASTERFORMAT,           ".8Bit           ≥Active Soft ED8 image     ≥ED8≥0")
AADD(MASTERFORMAT,           "0x1000000002000000≥PlayStation TIM (Type 2)  ≥TIM≥0")
AADD(MASTERFORMAT,           "0x1000000008000000≥PlayStation TIM (Type 8)  ≥TIM≥0")
AADD(MASTERFORMAT,           "0x1000000009000000≥PlayStation TIM (Type 9)  ≥TIM≥0")
AADD(MASTERFORMAT,           "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒ¥")
AADD(MASTERFORMAT,           "BIKf            ≥Bink (FFVIII)             ≥bik≥0")
AADD(MASTERFORMAT,           "SMK2            ≥Smacker                   ≥smk≥0")
AADD(MASTERFORMAT,           "FWS            ≥ShockWave Flash 3         ≥swf≥0")
AADD(MASTERFORMAT,           "FWS            ≥ShockWave Flash 4         ≥swf≥0")
AADD(MASTERFORMAT,           "FWS            ≥ShockWave Flash 5         ≥swf≥0")
AADD(MASTERFORMAT,           "0x02010148200101482060010180≥PSX Movie                 ≥STR≥0")
AADD(MASTERFORMAT,           "0x000001ba21    ≥mpeg animation            ≥mpg≥0")
//AADD(MASTERFORMAT,           "0x42494B66C44748≥BIK File                  ≥BIK≥0")
//AADD(MASTERFORMAT,           "BIK             ≥BIK File                  ≥BIK≥0")
AADD(MASTERFORMAT,           "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒ¥")
AADD(MASTERFORMAT,           "M.K.            ≥Amiga Protracker 4Chn Mod ≥MOD≥1080")
AADD(MASTERFORMAT,           "FLT4            ≥StarTrekker 4Chn Module   ≥MOD≥1080")
AADD(MASTERFORMAT,           "FLT8            ≥StarTrekker 8Chn Module   ≥MOD≥1080")
AADD(MASTERFORMAT,           "6CHN            ≥FastTracker 6Chn Module   ≥MOD≥1080")
AADD(MASTERFORMAT,           "8CHN            ≥FastTracker 8Chn Module   ≥MOD≥1080")
AADD(MASTERFORMAT,           "12CH            ≥FastTracker 12Ch Module   ≥MOD≥1080")
AADD(MASTERFORMAT,           "16CH            ≥FastTracker 16Ch Module   ≥MOD≥1080")
AADD(MASTERFORMAT,           "32CH            ≥FastTracker 32Ch Module   ≥MOD≥1080")
AADD(MASTERFORMAT,           "CD81            ≥Oktalyzer Atari Module    ≥MOD≥1080")
AADD(MASTERFORMAT,           "OCTA            ≥OctaComposer(?) Module    ≥MOD≥1080")
AADD(MASTERFORMAT,  ""+chr(0)+"SCRM         ≥ScreamTracker 3 Module    ≥S3M≥41")
AADD(MASTERFORMAT,           "Extended Module:≥FastTracker ][ Ext. Module≥XM ≥0")
AADD(MASTERFORMAT,           "OKTASONGCMOD    ≥Amiga Oktalyzer Module    ≥OKT≥0")
AADD(MASTERFORMAT,           "MMD             ≥Amiga OctaMED Module      ≥MED≥0")
AADD(MASTERFORMAT,           "DDMF            ≥X-Tracker Module          ≥DMF≥0")
AADD(MASTERFORMAT,           "DMDL            ≥N-Factor DigiTrakker Mod  ≥MDL≥0")
AADD(MASTERFORMAT,           "DSMFSONG        ≥DSIK Module v2 (RIFF)     ≥DSM≥8")
AADD(MASTERFORMAT, "PLM"+chr(26)+"`          ≥Disorder Tracker 2.0      ≥PLM≥0")
AADD(MASTERFORMAT,           "Funk            ≥FunkTracker Module        ≥FNK≥0")
AADD(MASTERFORMAT,           "0x50534D20      ≥MASI PSM [Epic Megagames] ≥PSM≥0")
AADD(MASTERFORMAT,           "Liquid Module:  ≥Liquid Tracker 1.0        ≥LIQ≥0")
AADD(MASTERFORMAT,           "USLM            ≥USM Player v1.0           ≥USM≥0")
AADD(MASTERFORMAT,           "D.T.            ≥Digital Tracker           ≥DTM≥0")
AADD(MASTERFORMAT,           "0x3202005343524D≥S3M saved by IT2.xx       ≥S3M≥41")
AADD(MASTERFORMAT,           "0x4d584d00      ≥Tiny GUS XM player        ≥MXM≥0")
AADD(MASTERFORMAT,           "0x534e54210000  ≥Prorunner 2.0 (Amiga)     ≥PRO≥0")
AADD(MASTERFORMAT,           "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒ¥")
AADD(MASTERFORMAT,    chr(26)+"`           ≥ScreamTracker 2 Module    ≥STM≥28")
AADD(MASTERFORMAT,      _3_CH0+ "SCRM         ≥STMIK 0.20 Module         ≥STX≥57")
AADD(MASTERFORMAT,           "AMF             ≥DSMi Module               ≥AMF≥0")
AADD(MASTERFORMAT, "AMM"+chr(26)+"            ≥Renegade Audio Manager Mod≥AMM≥0")
AADD(MASTERFORMAT,           "Extreme0        ≥Extreme Tracker Module 1.3≥AMS≥0")
AADD(MASTERFORMAT, "AMShdr"+chr(26)+"         ≥Velvet Studio Module 2.2  ≥AMS≥0")
AADD(MASTERFORMAT,           "FAR˛            ≥Farandole Composer Module ≥FAR≥0")
AADD(MASTERFORMAT,           "PSM˛            ≥Protracker Studio Mod     ≥PSM≥0")
AADD(MASTERFORMAT,           "PS16˛           ≥Protracker Studio 16 Mod  ≥PSM≥0")
AADD(MASTERFORMAT,           "PTMF            ≥PolyTracker Module        ≥PTM≥44")
AADD(MASTERFORMAT,           "IMPM            ≥Impulse Tracker Module    ≥IT ≥0")
AADD(MASTERFORMAT,           "MAS_UTrack_V00  ≥Ultratracker Module       ≥ULT≥0")
AADD(MASTERFORMAT,           "DSM            ≥DSIK Module v1            ≥DSM≥0")
AADD(MASTERFORMAT,           "MTM            ≥MultiTracker Module       ≥MTM≥0")
AADD(MASTERFORMAT,           "0x69662020      ≥669 Composer [Untitled]   ≥669≥0")
AADD(MASTERFORMAT,           "GDM˛            ≥Music & Sound Engine Mod  ≥GDM≥0")
AADD(MASTERFORMAT,           "CBA˘            ≥Heretics CBA NoiseDriver  ≥CBA≥0")
AADD(MASTERFORMAT, "PDM"+chr(26)+"            ≥Disorder Tracker 1.6      ≥PDM≥0")
AADD(MASTERFORMAT,           "UN0             ≥MikMak/UniMOD Module      ≥UNI≥0")
AADD(MASTERFORMAT,   "NO"+_2_CH0+"           ≥Liquid Tracker 0.14       ≥LIQ≥0")
AADD(MASTERFORMAT,           "ziRCONia        ≥Music Module Compressor   ≥MMC≥0")
AADD(MASTERFORMAT,           "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒ¥")
AADD(MASTERFORMAT,           "WAVEfmt         ≥Windows Wave              ≥WAV≥8")
AADD(MASTERFORMAT,           "Creative Voice F≥Creative Voice File       ≥VOC≥0")
AADD(MASTERFORMAT,  "FORM"+chr(0)+"           ≥Amiga IFF/8SVX            ≥IFF≥0")
AADD(MASTERFORMAT,  "FORM"+chr(0)+"           ≥Apple IFF                 ≥AIF≥0")
AADD(MASTERFORMAT,    ".snd"+_3_CH0+"         ≥Sun/NeXT Audio File       ≥AU ≥0")
AADD(MASTERFORMAT,           "sfbkLIST        ≥EMU SoundFont Bank        ≥SBK≥8")
AADD(MASTERFORMAT,           "GF1PATCH110     ≥GUS Midi Patch            ≥PAT≥0")
AADD(MASTERFORMAT,           ".ra˝            ≥RealAudio File            ≥RA ≥0")
AADD(MASTERFORMAT,           "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒ¥")
AADD(MASTERFORMAT,    "MThd"+_3_CH0+"        ≥Standard Midi song        ≥MID≥0")
AADD(MASTERFORMAT,           "RMIDdata        ≥Windows RIFF Midi         ≥RMI≥8")
AADD(MASTERFORMAT,    "FORM"+_3_CH0+"XDIRINFO≥X-midi                    ≥XMI≥0")
AADD(MASTERFORMAT,           "CTMF            ≥Creative Music File       ≥CMF≥0")
AADD(MASTERFORMAT,           "HMIMIDIP        ≥Human Machines Int. Midi  ≥HMP≥0")
AADD(MASTERFORMAT,           "JCH&f          ≥Vibrants Adlib Tune       ≥D00≥0")
AADD(MASTERFORMAT,           "SAdT            ≥S!P Adlib Tracker Tune    ≥SAT≥0")
AADD(MASTERFORMAT,           "CSAT           ≥S!P Compressed Adlib Tune ≥SAT≥0")
AADD(MASTERFORMAT,           "MTRACK          ≥Arkham MasterTracker Tune ≥MTR≥0")
AADD(MASTERFORMAT,           "RAD by REALiTY!!≥Reality Adlib Tune        ≥RAD≥0")
AADD(MASTERFORMAT,           "<oÔQUÓRoR       ≥Elyssis AMusic Tune       ≥AMD≥1062")
AADD(MASTERFORMAT,           "FMC!            ≥Faust Music Creator       ≥SNG≥0")
AADD(MASTERFORMAT,           "TRK01/TV.ES.    ≥RamJet RamTracker         ≥TRK≥0")
AADD(MASTERFORMAT, "MUS"+chr(26)+"            ≥DOOM Music File           ≥MUS≥0")
AADD(MASTERFORMAT,           "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒ¥")
AADD(MASTERFORMAT,           "MZ              ≥Standard EXE              ≥EXE≥0")
AADD(MASTERFORMAT,           "PKLITE Copr. 199≥PKLite Packed EXE         ≥EXE≥30")
AADD(MASTERFORMAT,      _3_CH0+ "LZ91         ≥LZEXE Packed EXE          ≥EXE≥25")
AADD(MASTERFORMAT,           "diet˘úÎ	        ≥Diet 1.45 Packed EXE      ≥EXE≥28")
AADD(MASTERFORMAT,    ""+_3_CH0+"WWP         ≥WWPack 3.0x Packed EXE    ≥EXE≥24")
AADD(MASTERFORMAT,           "AIN2            ≥AINEXE 2.2 Packed EXE     ≥EXE≥32")
AADD(MASTERFORMAT,           "UC2X            ≥UCEXE 2.3 Packed EXE      ≥EXE≥28")
AADD(MASTERFORMAT,  "tz√"+chr(0)+"È           ≥TinyProg 3.9 Packed EXE   ≥EXE≥28")
AADD(MASTERFORMAT,           "˘ÀCopyright (c)≥ComPack 4.5 Packed EXE    ≥EXE≥78")
AADD(MASTERFORMAT,           "RNC            ≥ProPack 2.08 Packed EXE   ≥EXE≥32")
AADD(MASTERFORMAT,           "RNC            ≥ProPack Compressed file   ≥RNC≥0")
AADD(MASTERFORMAT,           "¥LÕ!ùâ          ≥Diet Compressed file      ≥DLZ≥0")
AADD(MASTERFORMAT,           "S404            ≥StoneCracker 4.04 (Amiga) ≥S40≥0")
AADD(MASTERFORMAT,           "CrM2            ≥Crunchmania (Amiga)       ≥CRM≥0")
AADD(MASTERFORMAT,           "0xEB1C904E454320322E30≥PC98 floppy Image NEC2    ≥FLP≥0")
AADD(MASTERFORMAT,           "0xEB3C904E45432020352E30≥PC98 floppy Image NEC5    ≥FLP≥0")
AADD(MASTERFORMAT,           "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒ¥")
AADD(MASTERFORMAT,           "                ≥User Defined              ≥USR≥0" )

AEVAL( MASTERFORMAT, {|cSub|AADD(ARRCHOICE,cSub)} )

F_ReadIni()

FOR lenout := 1 to dfargc()
    patt:= dfargv(lenout)
    IF dfargc()==1
       patt:="/?"
    ENDIF
    F_ElabParam( patt )
NEXT

// preparazione schermo e parametri
IF !EMPTY( EXTPATH )
   IF right(EXTPATH,1) # "\"
      IF right(EXTPATH,1) # ":"
         EXTPATH+="\"
      ENDIF
   ENDIF
   EXTPATH:=upper( EXTPATH )
   IF !FILE( EXTPATH+"NUL" )
      BANNERONE()
      ?
      ? "MRIP error: Invalid path ["+EXTPATH+"]"
      SET COLOR TO
      ?
      quit
   ENDIF
ENDIF

IF FBATCH
   WHILE (pat_ptr := ASCAN(ARRCHOICE,"ƒƒƒƒ"))>0
      ADEL( ARRCHOICE, pat_ptr )
      ASIZE( ARRCHOICE, LEN(ARRCHOICE)-1 )
   ENDDO
ENDIF

// Check formato
IF !FBATCH .AND. EMPTY(ARRCHOICE)
   BANNERONE()
   ?
   ? "MRIP error: No valid formats"
   ? "Change INI parameter or command line parameter"
   SET COLOR TO
   ?
   quit
ENDIF

// Recoursive scan
F_FillArray()

IF EMPTY( AFILE2EXT )
   Desc_patt := "Error: Specified FileName"+if(LEN(FILEMASK)>1,"s","")+" not found..."
   IF !RECOURSE
      BANNERONE()
      ?  Desc_patt
   ELSE
      DEVPOS( ROW(), 0 )
      ?? Desc_patt
   ENDIF
   set COLOR to
   ?
   quit
ENDIF

setcancel(.F.)
setblink(.T.)
setblink(.F.)
setcolor("W+/N+*");?"";cls
setcursor(1)
setcursor(0)

pat_Ptr := 0
PARM    := F_CurName()
OLDPTR  := ""

IF FBATCH
   PROCESS_ALL := 3
   //restscreen(0,0,49,79,emtscrn())
   Big_wind()
   //F_Status()
ELSE
   PROCESS_ALL := 0
   for nRows = 0 to MAXROW()
      for nCols = 0 to MAXCOL() step 2
         if nRows%2==1
            @ nRows, nCols SAY "±≤" COLOR "W+/N+*"
         else
            @ nRows, nCols SAY "≤±" COLOR "W+/N+*"
         endif
      next
   next
   pat_Ptr := 0
ENDIF

while .T.
  DO CASE
     CASE PROCESS_ALL = 0
          pat_Ptr:=picklist(@pattern)
          DO CASE
             CASE lastkey() == K_ESC   .or.;
                  lastkey() == K_ALT_X
                  exit

             CASE lastkey() == K_F6
                  PROCESS_ALL:=3
                  pat_Ptr:=0
                  Big_wind()
                  TOTCOUNTER:=0
                  LOOP

             CASE lastkey() == K_F7
                  PROCESS_ALL:=1
                  pat_Ptr:=0
                  Big_wind()
                  TOTCOUNTER:=0
                  LOOP

             CASE lastkey() == K_F8
                  PROCESS_ALL:= 2
                  pat_Ptr--
                  Big_wind()
                  TOTCOUNTER:=0
                  LOOP

             CASE lastkey() == K_F9
                  F_hexview(aStaticone,PARM)
                  LOOP

             CASE lastkey() == K_SH_F9
                  F_Bav(aStaticone,PARM)
                  LOOP

             CASE lastkey() == K_F10
                  F_CngFile()
                  LOOP

             CASE lastkey() == K_F11
                  F_SWPRUNCMD("start http://www.baccan.it")
                  LOOP

             CASE lastkey() == K_F5
                  F_GetXor()
                  LOOP

             CASE lastkey()==K_SH_F5
                  F_SayXor()
                  LOOP

             OTHERWISE
                  Big_wind()
          ENDCASE
          pattern:= Alltrim(pattern)
          IF F_CheckFirst() // Passa quando viene selezionato un certo pattern
             LOOP
          ENDIF
     OTHERWISE
          IF F_CheckFirst() // Passa quando selezioniamo un gruppo
             IF SKIPIFLIB // Se estraggo una lib e ho lo skiplib attivo
                pat_Ptr:=len(ARRCHOICE) // Salto il file
                IF lastkey() == K_ESC
                   IF Alert( BIG_BREAK ,{"Stop Search"}) = 1
                      EXIT
                   ENDIF
                ENDIF
             ENDIF
             LOOP
          ENDIF
          IF pat_Ptr==0 .AND. PROCESS_ALL==3
             F_PreScan()
          ENDIF
          pat_Ptr++
          IF pat_Ptr > len(ARRCHOICE) .OR.; // End Scan
             ( pat_Ptr == len(ARRCHOICE)-1 .AND. SUBSTR(ATAIL(ARRCHOICE),45,3)=="USR")
             PROCESS_ALL:=0
             pat_Ptr    :=0
             IF EndScanMsg()
                EXIT
             ENDIF
             IF FBATCH
                PROCESS_ALL := 3
             ENDIF
             LOOP
          ENDIF
          pattern:=alltrim(left( ARRCHOICE[pat_Ptr],16))
          IF "ƒƒƒƒ" $ pattern            // Skip Pattern
             IF PROCESS_ALL==2
                PROCESS_ALL:=0
                pat_Ptr    :=0
                EndScanMsg()
             ENDIF
             LOOP
          ENDIF
          IF PROCESS_ALL==3              // Skip UNUSED
             IF !("-"+ALLTRIM(STR(pat_ptr))+"-"$FASTSCAN)
                LOOP
             ENDIF
          ENDIF
          F_Status()
  ENDCASE

  Pat_PTR   := if(Pat_PTR=0,len(ARRCHOICE),Pat_PTR)
  ext       := alltrim(substr(ARRCHOICE[Pat_PTR],45,3))
  SKIPBYTES := -(VAL(SUBSTR(ARRCHOICE[Pat_PTR],RAT("≥",ARRCHOICE[Pat_PTR])+1)))
  Desc_patt := alltrim(substr(ARRCHOICE[Pat_PTR],18,26))
  IF left(pattern,2) == "0x"
     pattern:=convert(pattern)
  ENDIF
  patlen := len(pattern)

  IF (hin:= F_fopen( PARM, FO_SHARED )) == -1
     RipLog( "Cannot open "+PARM )
     IF !FBATCH
        Alert( BIG_ERROR +"Cannot open;"+PARM,{"Quit"})
     ENDIF
     exit
  ENDIF
  filelen :=fseek(hin,0,2)
  IF filelen < patlen-skipbytes
     RipLog( "This file cannot contain the selected Pattern! (" +Desc_patt +")" )
     IF PROCESS_ALL = 0
        Alert( BIG_ERROR +"This file cannot contain;the selected Pattern!")
     ENDIF
     fclose(hin)
     LOOP
  ENDIF

  /* il posizionamento a skipbytes ä necessario, in quanto se una volta trovata
     la stringa devo tornare indietro evito il problema riscontrato ad es.
     nei files che iniziano con M.K., nei quali cercherebbe di posizionarsi
     prima dell'inizio di files!!!!
  */

  ***********************
  fseek(hin,-skipbytes,0)
  ***********************
  f_saymsg( "...Searching "+Desc_patt+" pattern...", "W/B" )
  filepos:=-skipbytes
  while filepos < filelen
        userbrk := .F.
        DO CASE
           CASE NEXTKEY()==K_ESC
                CLEAR TYPEAHEAD
                IF PROCESS_ALL>0
                   nWarning := Alert( BIG_BREAK ,{"Next pattern","Stop Search"})
                   DO CASE
                      CASE nWarning==1
                      CASE nWarning==2
                           PROCESS_ALL:=0
                      OTHERWISE
                           CLEAR TYPEAHEAD
                           LOOP
                   ENDCASE
                ELSE
                   nWarning := Alert( BIG_BREAK ,{"Another pattern","Continue"} )
                   DO CASE
                      CASE nWarning==1
                      OTHERWISE
                           CLEAR TYPEAHEAD
                           LOOP
                   ENDCASE
                ENDIF

                userbrk := .T.
                fclose(hin)
                IF writing
                   fclose(hout)
                   ferase(name) /// cancello l'ultimo file che non ä comunque completo
                ENDIF
                exit

           CASE NEXTKEY()==ASC("s") .OR. NEXTKEY()==ASC("S")
                filepos:=filelen
                CLEAR TYPEAHEAD
                LOOP
        ENDCASE

        CLEAR TYPEAHEAD

        cbuff   := replicate(chr(0), BUFLEN )
        bytesin := fXorread(hin,@cbuff, BUFLEN )
        filepos += bytesin
        IF bytesin  < BUFLEN
           cbuff := left(cbuff,BUFLEN)
        ENDIF
        match := at( pattern, cbuff )

        // Sono in un pattern speciale in grado di trovare subito la len
        IF match>0 .AND. ExactPattern( ext, hin, filepos-bytesin+match-1, aStaticone )
           // Riposiziono la posizione del file
           filepos := FSEEK( hin, 0, FS_RELATIVE )

        // Metodo standard
        ELSEIF match > 0
           IF !writing
              LOCCOUNTER++
              name:=F_ExtName( ext )
              writing:=.T.
              IF (hout:=fcreate(name)) == -1
                 Alert( BIG_ERROR +"Cannot create output file;"+name,{"Quit"})
                 fclose(hin)
                 twtquit()
              ENDIF

              /* skipper */
              IF Skipbytes < 0
                 fseek(hin,-(bytesin-(match-1)-(skipbytes)),1)
                 filepos-=(bytesin-(match-1)-(skipbytes))
                 START_POS := filepos
                 fXorread(hin,@cbuff,-(skipbytes))
                 FWRITE(hout,left(cbuff,-(skipbytes)),-(skipbytes))
                 fseek(hin,patlen,1)
                 filepos+=patlen-(skipbytes)
              ELSE
                 fseek(hin,-(bytesin-(match-1)-patlen),1)
                 filepos-=(bytesin-(match-1)-patlen)
                 START_POS := filepos-patlen
              ENDIF

              IF (FWRITE(hout,pattern,patlen)) # patlen
                 Alert(BIG_ERROR+"Error writing header",{"Quit"})
                 fclose(hin)
                 fclose(hout)
                 ferase(name) /// cancello l'ultimo file che non ä comunque completo
                 twtquit()
              ENDIF

           ELSE
              writing:=.F.
              IF FWRITE(hout,left(cbuff,match-1),match-1) # match-1
                 Alert(BIG_ERROR+"Error writing end of data",{"Quit"})
                 fclose(hin)
                 fclose(hout)
                 ferase(name) /// cancello l'ultimo file che non ä comunque completo
                 twtquit()
              ENDIF

/* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

              // problema con AIRFRAME: Subito dopo il modulo trova '8CHN'
              // e tornando indietro zappa 1080 bytes di samples, invalidandolo!
              //IF skipbytes < 0
                 //fseek(hout,skipbytes,1)
                 //FWRITE(hout,"")
              //ENDIF

   ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±± */

              fclose(hout)

              lenout = dfFileSize( name )
              //hout:=F_fopen(name)   /* check IF file is correct */
              //lenout:=fseek(hout,0,2)
              //fclose(hout)

              IF lenout < patlen-skipbytes .or.;
                 !CheckMore( aStaticone,name,ext,lenout,filelen )
                 ferase(name)
                 FALSEALARM++
                 RipLog( ,"False alarm: "+Desc_patt+" @"+dflong2hex(START_POS) )
                 LOCCOUNTER--
              ELSE
                 f_saymsg( "Match found,"+name+" created", "GR+/B")
                 RipLog( "Match found,"+name+" created: "+Desc_patt+" @"+dflong2hex(START_POS) )
              ENDIF
              fseek(hin,-(bytesin-match+1),1)
              filepos-=(bytesin-match+1)
           ENDIF

        ELSE
           /*
            devo riposizionarmi 'patlen' bytes indietro,per non perdermi
            un'eventuale pezzo di pattern ad EOF
           */
           IF writing
              IF filepos >= filelen /* sono arrivato ad eof senza trovare pattern */
                 IF (FWRITE(hout,cbuff,bytesin)) # bytesin
                    Alert(BIG_ERROR+"Error writing end of data",{"Quit"})
                    fclose(hin)
                    fclose(hout)
                    ferase(name) /// cancello l'ultimo file che non ä comunque completo
                    twtquit()
                 ENDIF
                 fclose(hout)

                 lenout = dfFileSize( name )

                 //hout:=F_fopen(name)   /* check IF file is correct */
                 //lenout:=fseek(hout,0,2)
                 //fclose(hout)

                 IF lenout < patlen-skipbytes .or.;
                    !CheckMore( aStaticone,name,ext,lenout,filelen )
                    FALSEALARM++
                    ferase(name)
                    RipLog( ,"False alarm: "+Desc_patt+" @"+dflong2hex(START_POS) )
                    LOCCOUNTER--
                 ELSE
                    f_saymsg( "Match found,"+name+" created", "GR+/B" )
                    RipLog( "Match found,"+name+" created: "+Desc_patt+" @"+dflong2hex(START_POS))
                 ENDIF

                 writing := .F.
              ELSE
                 IF (FWRITE(hout,left(cbuff,bytesin-patlen),bytesin-patlen)) # bytesin-patlen
                    Alert(BIG_ERROR+"Error writing data",{"Quit"})
                    fclose(hin)
                    fclose(hout)
                    ferase(name) /// cancello l'ultimo file che non ä comunque completo
                    twtquit()
                 ENDIF
              ENDIF
           ENDIF
           // To check !!
           IF bytesin>patlen
              filepos:=fseek(hin,-patlen,FS_RELATIVE)
           ENDIF
        ENDIF
        gauge(filepos,filelen)
  enddo
  IF userbrk
     IF FBATCH .and. PROCESS_ALL = 0
        exit
     ENDIF
     filepos :=FALSEALARM:=0
     name:=""
     writing := .F.
     LOOP
  ENDIF

  fclose(hin)

  IF PROCESS_ALL = 0
     IF LOCCOUNTER == 0 // non ne ho trovati giusti neanche 1
        tone(100,2)
     ELSE
        tone(200,1)
        tone(200,1)
     ENDIF

     RipLog(if(EMPTY(LOCCOUNTER),;
              "No ",;
              alltrim(str(LOCCOUNTER))+" ")+;
              Desc_patt+" Found."+;
              if(!EMPTY(FALSEALARM)," ( "+alltrim(str(FALSEALARM))+" false alarm"+if(FALSEALARM>1,"s","")+" )","")+CRLF)

     IF Alert( BIG_DONE +;
              if(EMPTY(LOCCOUNTER),;
                  "None",;
                  alltrim(str(LOCCOUNTER))+" "+;
                  Desc_patt)+;
                   " Found."+;
              if(!EMPTY(FALSEALARM),";( "+alltrim(str(FALSEALARM))+" false alarm"+if(FALSEALARM>1,"s","")+" )","")     ,;
              if(EMPTY(LOCCOUNTER),{"[Retry!]","[Back out 2 DOS]"},;
                             {"[Another Peek]","[That's Enough]"}),;
                             "W+/B+*") # 1
        exit
     ELSE
        filepos:=NAMECOUNT:=FALSEALARM:=LOCCOUNTER :=0
        name:=""
        writing := .F.
     ENDIF
  ELSE
     TOTCOUNTER+=LOCCOUNTER
     IF LOCCOUNTER > 0 .or. FALSEALARM > 0
        IF ISTHESAME
           RipLog(,PARM+" is a whole "+Desc_patt)
           f_say(" ... "+PARM+" is a whole "+Desc_patt,"gr+/b*")
           ISTHESAME:=.F.
        ELSE
           RipLog(if(EMPTY(LOCCOUNTER),;
                              "No ",;
                              alltrim(str(LOCCOUNTER))+" ")+;
                              Desc_patt+" Found."+;
                          if(!EMPTY(FALSEALARM)," ( "+alltrim(str(FALSEALARM))+" false alarm"+if(FALSEALARM>1,"s","")+" )",""))
           f_say(" ... "+if(EMPTY(LOCCOUNTER),"No",alltrim(str(LOCCOUNTER)))+" "+;
             Desc_patt+" Found."+;
             if(!EMPTY(FALSEALARM),;
                " ("+alltrim(str(FALSEALARM))+" false alarm"+if(FALSEALARM>1,"s","")+")",""),"W+/b*")
        ENDIF
     ENDIF
     filepos:=NAMECOUNT:=FALSEALARM:=LOCCOUNTER :=0
     name:=""
     writing := .F.
  ENDIF
enddo
IF OUTDEBUG>0 .AND. HLOG>0
   IF FBATCH
      IF SECONDS()<nTime
         nTime := SECONDS()+(86340-nTime)
      ELSE
         nTime := SECONDS()-nTime
      ENDIF
      IF FBATCHFAST
         nTime -= 5
      ENDIF
      RipLog( "Ripping time : " +dfSec2Time(nTime) )
   ENDIF
   fclose(HLOG)
ENDIF

twtquit()
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROC twtquit()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
local row
setcolor("W/N");?""

dfStdEnd()

setblink(OLDBLINK)
setcursor(0)
setcursor(1)
quit
RETURN


* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION Picklist(patt)
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL cName := "",  nSet, cScr,csc2
setcursor(1)
setcursor(0)

dispbegin()
F_Menu()
dfShade( 2, 4, maxrow()-14, 54  )
dfsaybox( 2, 5, maxrow()-14, 55,"n/B" ,"w/b","W/B" )
@ 2, 6       SAY "≥"                            COLOR "W+/B"
@row(),col() say " SeArCh PaTTeRn "             COLOR "b+/W*"
@Row(),col() say "≥"                            COLOR "BG+/B"
@row(),col() say "   PaTTeRn DeScRiPtIoN    "   COLOR "R/W*"
@Row(),col() say "≥"                            COLOR "BG+/B"
@Row(),col() say "ExT"                          COLOR "RB/W*"
@Row(),col() say "≥"                            COLOR "W+/B"
dispend()

while .T.
    nSet := dfWar( 3, 7, maxrow()-15, 53, ARRCHOICE,.F.,"BG+/B","gr+/r" )
    IF lastkey() == K_ENTER
       patt := left( ARRCHOICE[nSet],16)
    ENDIF
    IF lastkey() == K_F7      ; nset:=1; ENDIF

    IF lastkey() == K_F6      ; nset:=1; ENDIF
    IF lastkey() == K_F5      ; nset:=1; ENDIF
    IF lastkey() == K_SH_F5   ; nset:=1; ENDIF
    IF lastkey() == K_SH_F9   ; nset:=1; ENDIF
    IF lastkey() == K_F10     ; nset:=1; ENDIF
    IF lastkey() == K_F11     ; nset:=1; ENDIF
    IF lastkey() == K_F9      ; nset:=1; ENDIF

    IF lastkey() == K_F8 .and. nset > len(ARRCHOICE)-2
       LOOP
    ENDIF

    IF nset == len(ARRCHOICE) .AND. SUBSTR(ATAIL(ARRCHOICE),45,3)=="USR"  // user defined
       csc2 := savescreen( 3,3,23 ,23 )
       setcolor("bg+/r")
       dfShade( 3,2,6,19 )
       dfSayBox(  3,3,6,20, "w+/r", "n/r", "bg+/r" )
       @ 4,8 say "Pattern:"
       __keyboard(alltrim(patt))
       patt:=dfaliveget(5 ,4,16,"gr+/r")
       IF EMPTY(patt) .or. lastkey()=K_ESC
          restscreen(3,3,23,23,csc2)
          LOOP
       ENDIF
       ARRCHOICE[nset]:=padr(patt,16)+substr(ARRCHOICE[nset],17)

       dfShade( 11,2,14,19 )
       dfSayBox(  11,3,14,20, "w+/r", "n/r", "bg+/r" )
       @ 12,7 say "Extension:"
       __keyboard(upper(substr(ARRCHOICE[len(ARRCHOICE)],45,3)))
       cname=dfaliveget( 13 ,10,3,"gr+/r")
       IF EMPTY(cname) .or. lastkey()=K_ESC
          restscreen(  3,3,23,23,csc2)
          LOOP
       ENDIF
       ARRCHOICE[nset]:=left(ARRCHOICE[nset],44)+upper(padr(cname,3))+substr(ARRCHOICE[nset],48)
       WHILE .T.
             dfShade( 19,2,22,19 )
             dfSayBox(  19,3,22,20, "w+/r", "n/r", "bg+/r" )
             @ 20,8 say "Offset:"
             //cname:=""
             __keyboard(upper(substr(ARRCHOICE[nset],49)))
             cname:=upper(ALLTRIM(dfaliveget(21 ,8,6,"gr+/r")))

             IF EMPTY(cname) .or. lastkey()=K_ESC
                EXIT
             ELSE
                IF !(LEFT(CNAME,1) $ "0123456789")
                   TONE(100,1)
                   TONE(100,1)
                ELSE
                   IF substr(cname,2,1) == "X"
                      cname:=alltrim(str(dfhex2dec( substr(cname,3) )))
                   ENDIF
                   exit
                ENDIF
             ENDIF
       ENDDO
       IF EMPTY(cname) .or. lastkey()=K_ESC
          restscreen(3,3,23,23,csc2)
          LOOP
       ENDIF
       ARRCHOICE[nset] :=left(ARRCHOICE[nset],48)+alltrim(str(val(cname)))
    ENDIF
    exit
enddo
RETURN nset

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION convert( patt )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL ret:="",x
IF len(patt)>2
   patt:=substr(patt,3)
   patt:=if(len(patt) % 2 = 1 ,"0","")+patt
   for x := 1 to  len(patt)-1 step 2
       ret+=chr(dfhex2dec(substr(patt,x,2)))
   NEXT
ELSE
   ret:=chr(0)
ENDIF

RETURN ret

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION Dfaliveget(_Def, _Def1, _Def2, _Def3)
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

LOCAL nNum, cStr, _Def4, cStr1 := "˙"+Chr(7)+"˛"+Chr(4)+"€≤±∞  "

IF _Def3 == NIL
   _Def3 := Setcolor()
ENDIF

Dfpushcursor()
Setcursor(0)
nNum := 0
cStr := ""
Devpos(_Def, _Def1)
Devout(Padr(cStr, _Def2), _Def3)

WHILE nNum <= _Def2

   WHILE .T.

      _Def4 := inkey(0.1)

      IF _Def4 == 27

         EXIT

      ELSEIF _Def4 == 13

         EXIT

      ELSEIF _Def4 >= 32 .AND. nNum < _Def2

         EXIT

      ELSEIF (_Def4 == 8 .OR. _Def4 == 19) .AND. nNum > 0

         Devpos(_Def, _Def1 + nNum)
         IF nNum < 16 /* SPECIFICO PER MRIPPER */
            Devout(" ", _Def3)
         ENDIF
         --nNum
         cStr := Left(cStr, Len(cStr) - 1)

      ELSE
         //IF nNum < _Def2 /* NON FA LA STELLINA SE MAX CHAR */
         IF nNum < 16 /* SPECIFICO PER MRIPPER */
            cStr1 := Substr(cStr1, 2) + Left(cStr1, 1)
            Devpos(_Def, _Def1 + nNum)
            Devout(Left(cStr1, 1), _Def3)
         ENDIF
      ENDIF

   ENDDO

   IF _Def4 = 27

      EXIT

   ENDIF

   IF _Def4 = 13
      IF nNum < 16 /* SPECIFICO PER MRIPPER */
         devpos(row(),col()-1)
         Devout(" ")
      ENDIF

      EXIT

   ENDIF

   cStr := cStr + Chr(_Def4)
   Devpos(_Def, _Def1 + nNum)
   Devout(Chr(_Def4), _Def3)
   ++nNum

ENDDO

Devpos(_Def, _Def1)
Devout(cStr := Padr(cStr, _Def2), _Def3)
Dfpopcursor()

RETURN cStr


* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION dfWar( nTop, nLeft, nBottom, nRight, aSource, lLOOP, cNormal, cEvi )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//STATIC NACTUAL := 1, NOFFSET := 1
//LOCAL nRet := 0, NACTUAL := 1, nDis, NOFFSET := 1
LOCAL nRet := 0, nDis
LOCAL nRow:=nBottom-nTop+1, nCol:=nright-nLeft+1
LOCAL nLen:=LEN(aSource), n2Say, aValue:={}

//DEFAULT lLOOP   TO .F.
//DEFAULT cNormal TO "W+/B"
//DEFAULT cEvi    TO "B+/W"

AEVAL( aSource, {|cSub|AADD(aValue,PADR(cSub,nCol))} )

WHILE .T.
   dispbegin()
   FOR nDis := nTop TO nTop+nRow-1
      N2SAY:=NDIS-NTOP+1+NACTUAL-NOFFSET
      IF n2Say>nLen
         @ nDis, nLeft SAY SPACE(nCol)   COLOR cNormal
      ELSE
         @ nDis, nLeft SAY aValue[n2Say] COLOR cNormal
      ENDIF
   NEXT
   @ nTop+NOFFSET-1, nLeft SAY AVALUE[NACTUAL] COLOR cEvi
   dispend()

   F_Inkey(0)
   DO CASE
      CASE LASTKEY()==K_ESC .or. LASTKEY()==K_ALT_X
           EXIT

      CASE ALTMEM .AND. LASTKEY()== 306 // alt-m
           Alert(MINI_LOGO+ "Written by Peruch Emiliano (Ian/TWT);and Baccan Matteo (Teo/TWT);"+;
                 "Memory information;"+;
                 "0: "+(str(memory(0),6,0))+";"+;
                 "1: "+(str(memory(1),6,0))+";"+;
                 "2: "+(str(memory(2),6,0))+";"+_COMPILE_DATE_,,"GR+/N")

      CASE LASTKEY()==K_DOWN
           NACTUAL++
           IF NACTUAL<LEN(AVALUE) .and. "ƒƒƒƒ" $ aValue[NACTUAL]
              NACTUAL++
              NACTUAL := MIN(NACTUAL,nLen)
              NOFFSET++; NOFFSET:=MIN(NOFFSET,nRow)
           ENDIF
           DO CASE
              CASE lLOOP .AND. NACTUAL>nLen
                   NACTUAL := NOFFSET := 1
              CASE NACTUAL>nLen
                   NACTUAL := nLen
              OTHERWISE
                   NACTUAL := MIN(NACTUAL,nLen)
                   NOFFSET++; NOFFSET:=MIN(NOFFSET,nRow)
           ENDCASE

      CASE LASTKEY()==K_UP
           NACTUAL--
           IF NACTUAL>1 .and. "ƒƒƒƒ" $ aValue[NACTUAL]
              NACTUAL--
              NACTUAL := MAX(NACTUAL,1)
              NOFFSET--; NOFFSET := MAX(NOFFSET,1)
           ENDIF
           DO CASE
              CASE lLOOP .AND. NACTUAL<1
                   NACTUAL := nLen; NOFFSET := nRow
              CASE NACTUAL<1
                   NACTUAL := 1
              OTHERWISE
                   NACTUAL := MAX(NACTUAL,1)
                   NOFFSET--; NOFFSET := MAX(NOFFSET,1)
           ENDCASE

      CASE LASTKEY()==K_HOME
           NACTUAL := NOFFSET := 1

      CASE LASTKEY()==K_END
           *********** bugfix by ˙ƒÕ˛≥íÔ˛Õƒ˙ ***********
           IF nLen >= nRow
              NACTUAL := nLen
              NOFFSET := nRow
           ELSE
              NOFFSET := NACTUAL := nLen
           ENDIF
      CASE LASTKEY()==K_PGUP
           IF NOFFSET#1
              NACTUAL-=(NOFFSET-1)
              NOFFSET:=1
           ELSE
              NACTUAL-=(nRow-1); NACTUAL:=MAX(NACTUAL,1)
           ENDIF
           IF NACTUAL>1 .and. "ƒƒƒƒ" $ aValue[NACTUAL]
              NACTUAL--
              NACTUAL := MAX(NACTUAL,1)
              NOFFSET--; NOFFSET := MAX(NOFFSET,1)
           ENDIF

      CASE LASTKEY()==K_PGDN
           IF NOFFSET#nRow
              NACTUAL+=(nRow-NOFFSET)
              NOFFSET:=nRow
              nDis   :=NACTUAL-nLen
              IF nDis>0
                 NACTUAL-=ndis
                 NOFFSET-=ndis
              ENDIF
           ELSE
           *********** bugfix by ˙ƒÕ˛≥íÔ˛Õƒ˙ ***********
              IF NACTUAL < nlen-NOFFSET // ˙ƒÕ˛≥íÔ˛Õƒ˙
                 NACTUAL+=(nRow-1)
              ELSE
                 NACTUAL := nLen
              ENDIF
           ******************************************
           ENDIF
           IF NACTUAL<len(avalue) .and. "ƒƒƒƒ" $ aValue[NACTUAL]
              NACTUAL++
              NACTUAL := MIN(NACTUAL,nLen)
              NOFFSET++; NOFFSET:=MIN(NOFFSET,nRow)
           ENDIF

      CASE LASTKEY()==45 // "-"
           IF F_DecName()
              writecurrent()
           ENDIF

      CASE LASTKEY()==43 // "+"
           IF F_IncName()
              writecurrent()
           ENDIF

      CASE LASTKEY()==K_RETURN
           nRet:=NACTUAL
           EXIT

      CASE (lastkey() == K_F6    .or.;
            lastkey() == K_F7    .or.;
            lastkey() == K_F8    .or.;
            lastkey() == K_F5    .or.;
            lastkey() == K_SH_F5 .or.;
            lastkey() == K_SH_F9 .or.;
            lastkey() == K_F10   .or.;
            lastkey() == K_F11   .or.;
            lastkey() == K_F9 )
           nRet:=NACTUAL
           EXIT


   ENDCASE
ENDDO

RETURN nRet

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
proc bannerone()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
setcolor("W+/n")
?" ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø"
?" ≥≤±∞ ";setcolor("bg+/n") ;??"   ˛ Multi Ripper "+padr(RIPVERSION+" ˛",8)+"     The Multi-Purpose File Extractor   ";setcolor("W+/n");??"  ∞±≤≥"
?" ≥≤±∞ ";setcolor("RB+/n");?? "     Shareware Copyright (C)2000 by"
setcolor("GR+/n");??" ˙ƒÕIaN & TeOÕƒ˙ oF T</\>T";setcolor("W+/n");??"       ∞±≤≥"
?" ¿ƒƒƒƒƒƒ≥ Go at         http://www.baccan.it         for last release ≥ƒƒƒƒƒƒŸ"

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNC getcurrent()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
RETURN ("Source = "+ALLTRIM(PARM)+";Destination Path = "+if(EMPTY(EXTPATH),"Current",ALLTRIM(EXTPATH)))

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION EndScanMsg()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL flagfound := TOTCOUNTER>0, lRet := .F.
showtot()
//flushcache()

IF FBATCH
   IF F_IncName()
      writecurrent()
   ELSE
      lRet := .T.
      f_saymsg( "...Quitting 2 Dos in 5 secs...", "GR+/B" )
      IF !FBATCHFAST
         inkey(5)
      ENDIF
   ENDIF
ELSE
   Alert( BIG_DONE +"Scan Completed. ",{if(!flagfound,"Nothing found","Let me see...")},"w+/rb")
   IF flagfound
      f_saymsg( "... Press any Key ... if you don't find 'any' key press enter", "bG+/B" )
      inkey(30)
   ENDIF
ENDIF
RETURN lRet

/*
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE flushcache()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
IF FFLUSH
   setcursor(1)
   setcursor(0)  // la dfflushc() stranamente mi pizza il cursore...
   f_saymsg( "...Flushing Cache...", "GR+/B" )
   dfflushc()
   f_saymsg( "", "GR+/B" )
   setcursor(1)
   setcursor(0)
ENDIF

return
*/

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC proc showtot()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL cStr
IF FBATCH
   RipLog( CRLF +Replicate("ƒ",79) )
   RipLog( "Local Files Extracted : "+alltrim(str(LOCCOUNTER)) )
   RipLog( Replicate("ƒ",79)+CRLF )
ENDIF

IF (FBATCH .AND. F_LastName()) .OR. !FBATCH
   IF TOTCOUNTER>0
      cStr := " ... Total Files Extracted : "+alltrim(str(TOTCOUNTER))
   ELSE
      cStr := " ... NO Files Extracted"
   ENDIF
   RipLog( CRLF +Replicate("ƒ",79) )
   RipLogSay( cStr )
   RipLog( Replicate("ƒ",79) +CRLF )
ENDIF

return

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE Big_wind()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
dfShade( 2,4,maxrow()-14 ,73 )
dfSayBox( 2,5,maxrow()-14 ,74, "W+/b*", "b/b*", "bg+/b*" )
dfSayBox( 3,6,maxrow()-15 ,73, "b/b*", "w+/b*", "bg+/b*" )
RETURN

/*
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION TWT_CRIPPLE( screen )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
local xx,Y_1,Y_2,delay ,a,yy
Y_1 := 0
y_2 := 49
IF cpu() + fpu() > 8
   delay := 1000
else
   delay := 500
ENDIF
for xx := 1 to 79
   restscreen( y_1,0,y_2,xx, screen )
   for yy := 1 to delay
      a := 0
      a := a+1
   NEXT
NEXT
RETURN NIL
*/

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION fXorRead( hin, cbuff, len )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL bytesin := fread(hin,@cbuff, len )

IF XORPATTERN>0
   dfXorPattern( @cBuff, CHR(XORPATTERN) )
ENDIF

RETURN bytesin

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE RipLog( cNormal, cVerbose )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL clogname

IF OUTDEBUG!=0
   IF HLOG==0
      clogname := EXTPATH+"MRIP.LOG"
      IF( HLOG:=fcreate(clogname) )>0
         FWRITE(HLOG,strtran(MINI_LOGO,";",CRLF))
         FWRITE(HLOG,CRLF+Replicate("ƒ",79)+CRLF+CRLF)
      ELSE
         Alert("MRIP error: Cannot Create ["+clogname+"]")
         HLOG:=-1
      ENDIF
   ENDIF

   DO CASE
      CASE HLOG<=0

      CASE OUTDEBUG==1 // Normal
           IF !EMPTY(cNormal)
              FWRITE( HLOG, cNormal +CRLF )
           ENDIF

      CASE OUTDEBUG==2 // Verbose
           IF !EMPTY(cNormal)
              FWRITE( HLOG, cNormal +CRLF )
           ENDIF
           IF !EMPTY(cVerbose)
              FWRITE( HLOG, cVerbose +CRLF )
           ENDIF
   ENDCASE
ENDIF

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE RipLogSay( a, b )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
f_say( a, "gr+/b*" )
IF LEFT(a,5)==" ... "
   a := SUBSTR( a, 6 )
ENDIF
RipLog( a, b )
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_SayXor()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL csc2, nOpt, aDir2

aDir2 := {;
 "Filename     ≥XorValue≥Description                                       ",;
 "ƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ",;
 "REALTHNG.000 ≥   CC   ≥The Real Thing by Capacala (1 M.K.,1 6CHN, 4 8CHN)",;
 "CC_UREAH.EXE ≥   CC   ≥Unreal Thing by Capacala (1 S3M)                  ",;
 "DREAM.DAT    ≥   A5   ≥Crystal Dream by Triton (11 LBM , 4 MOD)          ",;
 "DEJAVU.EXE   ≥   34   ≥DejaVu by Synergy Design (2 MOD)                  ",;
 "TP4_INV.EXE  ≥   AA   ≥The Party 4 Invitation by Dust (1 S3M)            ",;
 "LISA.EXE     ≥   17   ≥LISA by Eclipse ( MOD,PCX,EXE (ALSO INSIDE)       ",;
 "DEMO.EXE     ≥   D9   ≥Jumble by G&G Demowarez ( MOD,PCX,EXE )           " }
//1234567890123456789012345678901234567890123456789012345678901234567890123

NACTUAL := NOFFSET := 1

csc2 := savescreen( 3,1,4+LEN(aDir2)+1,77 )
dfShade( 3,1,4+LEN(aDir2),75 )
dfSayBox( 3,2,4+LEN(aDir2),76, "w+/r", "n/r", "bg+/r" )

nOpt := dfWar( 4, 3, 3+LEN(aDir2), 75, aDir2,.F.,"W+/R","W+/BG" )

IF nOpt>2 .AND. LASTKEY()!=K_ESC
   XORPATTERN := dfHex2Dec( SUBSTR(aDir2[nOpt],18,2) )
ENDIF

restscreen(3,1,4+LEN(aDir2)+1,77,csc2)

NACTUAL := NOFFSET := 1

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_GetXor()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL csc2 := savescreen( 3,3,23 ,23 )
setcolor("bg+/r")
dfShade( 3,2,6,19 )
dfSayBox(  3,3,6,20, "w+/r", "n/r", "bg+/r" )
@ 4,4 say "Hex Pattern"
XORPATTERN := dfHex2Dec(ALLTRIM(LEFT(dfaliveget(5,4,2,"gr+/r"),2)))
restscreen(3,3,23,23,csc2)
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_Menu()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//restscreen(0,0,49,79,emtscrn())
F_Status()
dfShade( 2, 58, 35, 73 )
dfsaybox( 2, 58, 35, 74,"n/B" ,"w/b","W/B" )
@ 2, 59         SAY "›"                 COLOR "W+/B"
@ row(),col()   say "MrIpPEr  mENu"     COLOR "b+/W*"
@ Row(),col()   say "|"                 COLOR "W+/B"
@ row()+1, 59   SAY "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"   COLOR "W+/B"
@ row()+1, 59   SAY "   Scan Type   "   COLOR "W+/B"
@ row()+1, 59   SAY "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"   COLOR "W+/B"
@ row()+1, 59   SAY "F6 Optimized"      COLOR "W+/B"
@ row()+1, 59   SAY "F7 Global"         COLOR "W+/B"
@ row()+1, 59   SAY "F8 Local"          COLOR "W+/B"
@ row()+1, 59   SAY "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"   COLOR "W+/B"
@ row()+1, 59   SAY "F5 XOR Pat[" +RIGHT(dfDec2Hex(XORPATTERN),2) +"]"    COLOR "W+/B"
@ row()+1, 59   SAY "F5 XOR Table"     COLOR "W+/B"
@ row()+1, 59   SAY "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"   COLOR "W+/B"
@ row()+1, 59   SAY "F9 Hex Viewer"     COLOR "W+/B"
@ row()+1, 59   SAY "F9 Bin Viewer"    COLOR "W+/B"
@ row()+1, 59   SAY "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"   COLOR "W+/B"
@ row()+1, 59   SAY "F10 Change File"   COLOR "W+/B"
@ row()+1, 59   SAY "F11 Distro site"   COLOR "W+/B"
@ row()+1, 59   SAY "ALT+M Free Mem"    COLOR "W+/B"
@ row()+1, 59   SAY "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ"   COLOR "W+/B"
@ row()+1, 59   SAY "[] Move Curs"    COLOR "W+/B"
@ row()+1, 59   SAY "[Ÿ] Select"       COLOR "W+/B"
@ row()+1, 59   SAY "[ESC] Quit"        COLOR "W+/B"
@ row()+1, 59   SAY "[+] Next File"     COLOR "W+/B"
@ row()+1, 59   SAY "[-] Prev File"     COLOR "W+/B"
@ row()+2, 59   SAY "Formats : " +ALLTRIM(STR(LEN(MASTERFORMAT))) COLOR "W+/B"
@ row()+2, 59   SAY "Libraries : " +ALLTRIM(STR(LEN(ARRLIBS))) COLOR "W+/B"
f_saymsg( "User input", "Gb+/B" )
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE F_Status()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL cStr
dispbegin()
dfShade( maxrow()-11,4,maxrow()-4 ,73 )
dfSayBox( maxrow()-11,5,maxrow()-4 ,74, "n/b", "w+/b", "b/b" )
f_saystatus( "STATUS" )
writecurrent()
cStr := "EXT:" +ALLTRIM(STR(TOTCOUNTER))
@ MAXROW()-4, 74-LEN(cStr) SAY cStr COLOR "R+/b"
@ MAXROW()-4, 6 SAY "≥FREEWARE VERSION≥" COLOR "R+/b"
dispend()
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_PreScan()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL nHandle, cBuf := SPACE( BUFLEN ), nRead, cPattern, nPatPos := 1
LOCAL filepos, filelen, nPat, aPat := {}, nRet, nKey

F_Status()

FASTSCAN := ""
nHandle  := F_FOPEN( ALLTRIM(PARM), FO_SHARED )

nPat     := LEN(ARRCHOICE)-2
IF LEN(ARRCHOICE)>0 .AND. !(SUBSTR( ATAIL(ARRCHOICE), 45, 3 )=="USR")
   nPat := LEN(ARRCHOICE)
ENDIF
IF nHandle>0 .AND. nPat>0
   f_saystatus( "PreScanning ... <S> to Stop <R> for Relative Optimize" )
   filepos  := 0
   filelen  := dfFileSize( nHandle )

   FOR nPatPos := 1 TO nPat
      cPattern := ALLTRIM(left(ARRCHOICE[nPatPos],16))
      IF !("ƒƒƒƒƒ"$cPattern)
         IF left(cPattern,2) == "0x"
            cPattern:=convert(cPattern)
         ENDIF
         AADD( aPat, {cPattern,"-"+ALLTRIM(STR(nPatPos))+"-",SUBSTR(ARRCHOICE[nPatPos],18,26)} )
      ENDIF
   NEXT
   nPat := LEN(aPat)

   f_say( "Start with prescanning ...", "W+/b*" )
   WHILE ( nRead := FREAD( nHandle, @cBuf, BUFLEN ) ) > 0
      @ maxrow()-6,6 say PADL(MIN(filepos+BUFLEN,filelen),10) COLOR "Rb+/B"
      dfPro(maxrow()-6,17,73,MIN(filepos+BUFLEN,filelen),filelen,"G+/B")
      FOR nPatPos := 1 TO nPat
         cPattern := aPat[nPatPos][1]
         DO CASE
            CASE aPat[nPatPos][2]$FASTSCAN
            OTHERWISE
                 IF cPattern$cBuf
                    f_say( "      Found "+aPat[nPatPos][3], "W+/b*" )
                    FASTSCAN += aPat[nPatPos][2]
                    ADEL( aPat, nPatPos )
                    ASIZE( aPat, LEN(aPat)-1 )
                    nPat--
                    nPatPos--
                 ENDIF
         ENDCASE
      NEXT
      IF nRead>16
         filepos := FSEEK( nHandle, -16, FS_RELATIVE )
      ENDIF
      nKey := F_inkey()
      DO CASE
         CASE UPPER(CHR(nKey)) == "S"
              FASTSCAN := ""
              EXIT

         CASE UPPER(CHR(nKey)) == "R"
              EXIT

         CASE nKey == K_ESC
              nRet := Alert( BIG_BREAK ,{"Continue"      ,;
                                         "Stop opt."     ,;
                                         "Relative opt." ,;
                                         "Quit"          })
              DO CASE
                 CASE nRet==2
                      FASTSCAN := ""
                      EXIT

                 CASE nRet==3
                      EXIT

                 CASE nRet==4
                      FASTSCAN    := ""
                      PTRFILENAME := 1
                      AFILE2EXT   := { {1,""} }
                      EXIT
              ENDCASE
      ENDCASE
   ENDDO
   f_say( "End prescanning", "W+/b*" )
ENDIF
IF nHandle>0
   FCLOSE( nHandle )
ENDIF

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION F_CheckFirst()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL lRet := .F.

IF !(PARM==OLDPTR)
   OLDPTR := PARM

   LOCCOUNTER := 0

   RipLog( dfToken(getcurrent(),";",1) +CRLF )
   RipLog( dfToken(getcurrent(),";",2) +CRLF )

   DO CASE
      CASE CHKEXELIB( aStaticone )
           lRet := .T.

      CASE F_IsExeWin( PARM )
           IF FBATCH .OR. ;
              Alert( {"Dos",;
                      "WIN16/OS2",;
                      "Linear",;
                      "Linear Os2",;
                      "Win386",;
                      "Portable",;
                      "HP DL",;
                      "Phar Lap MP",;
                      "Phar Lap P2",;
                      "Phar Lap P3"  }[dfexetype(PARM)]+;
                      " EXE Detected;Decompile Resources?",;
                       {"Yes","No"},"W+/N*" )==1
              lRet := F_ResDecomp(PARM,,aStaticone)
           ENDIF
   ENDCASE

   // Librerie e exe windows non si espandono
   IF EXPAND .AND. !lRet
      F_Expand( aStaticone )
   ENDIF
ENDIF

RETURN lRet

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_FillArray( cDir )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL nMask, nPos, nSep, aDir, nLenDir, cFileMask, cRelDir, cOldMask, lSkip
LOCAL nDmm

DEFAULT cDir TO ""

IF LEN(cDir)>0
   cDir := UPPER(ALLTRIM(cDir))
   cDir += "\"
ELSE
   IF RECOURSE
      BANNERONE()
      SET COLOR TO
      ? "Directory scanning ..."
      ?
      ?
   ENDIF
ENDIF

FOR nMask := 1 TO LEN( FILEMASK )
   IF F_INKEY()==K_ESC
      IF RECOURSE
         set COLOR to
         ?
         quit
      ENDIF
   ENDIF
   cFileMask := FILEMASK[nMask]
   lSkip     := .F.

   IF LEN(cDir)>0
      nSep      := MAX( RAT(":",cFileMask), RAT("\",cFileMask) )
      cOldMask  := ALLTRIM(UPPER(SUBSTR(cFileMask,1,nSep)))
      cFileMask := cDir +SUBSTR(cFileMask,nSep+1)
      lSkip     := !(cOldMask==LEFT(cDir,LEN(cOldMask)))

      IF (nDmm:=F_FOPEN( LEFT(cFileMask,MAX( RAT(":",cFileMask), RAT("\",cFileMask) ))+"NUL" ))==-1

         lSkip := .T.
      ELSE
         FCLOSE( nDmm )
      ENDIF
   ENDIF

   IF !lSkip
      IF !("*"$cFileMask .OR. "?"$cFileMask)
         IF FILE(cFileMask)
            aDir := { {cFileMask} }
         ELSE
            aDir := {}
         ENDIF
      ELSE
         aDir := DIRECTORY(cFileMask)
      ENDIF

      IF RECOURSE
         DEVPOS( ROW(), 0 ); DEVOUT( PADR(LTRIM(PADL(cFileMask,79)),79) )
      ENDIF

      IF !EMPTY(aDir)
         AADD( AFILE2EXT, {1,{}} )
         IF LEN(cDir)>0
            cRelDir := cDir
         ELSE
            IF !("*"$cFileMask .OR. "?"$cFileMask)
               cRelDir := ""
            ELSE
               cRelDir := LEFT( cFileMask, MAX( RAT(":",cFileMask), RAT("\",cFileMask) ) )
            ENDIF
         ENDIF
         AEVAL( aDir, {|aSub|AADD( ATAIL(AFILE2EXT)[2], cRelDir+aSub[F_NAME])} )
      ENDIF

      IF RECOURSE
         nSep := MAX( RAT(":",cFileMask), RAT("\",cFileMask) )
         aDir := DIRECTORY( LEFT( cFileMask, nSep )+"*.*", "D" )
         AEVAL( aDir, {|aSub|IF("D"$aSub[F_ATTR]      .AND.;
                                !(aSub[F_NAME]=="..") .AND.;
                                !(aSub[F_NAME]=="."),;
                            F_FillArray(LEFT( cFileMask, nSep )+aSub[F_NAME]),)} )
      ENDIF
   ENDIF
NEXT
IF LEN(cDir)==0 .AND. RECOURSE
   DEVPOS( ROW(), 0 ); DEVOUT( SPACE(79) )
ENDIF

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION F_DecName()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL lRet := .F.

IF PTRFILENAME>1 .OR. AFILE2EXT[PTRFILENAME][1]>1
   IF AFILE2EXT[PTRFILENAME][1]==1
      PTRFILENAME--
      AFILE2EXT[PTRFILENAME][1]:=LEN(AFILE2EXT[PTRFILENAME][2])
   ELSE
      AFILE2EXT[PTRFILENAME][1]--
   ENDIF
   PARM := F_CurName()
   lRet := .T.
ENDIF

RETURN lRet

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION F_IncName()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL lRet := .F.

IF !F_LastName()
   IF AFILE2EXT[PTRFILENAME][1]<LEN(AFILE2EXT[PTRFILENAME][2])
      AFILE2EXT[PTRFILENAME][1]++
   ELSE
      PTRFILENAME++
      AFILE2EXT[PTRFILENAME][1]:=1
   ENDIF

   PARM := F_CurName()
   lRet := .T.
ENDIF

RETURN lRet

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION F_LastName()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
RETURN !(PTRFILENAME<len(AFILE2EXT) .OR. ;
         AFILE2EXT[PTRFILENAME][1]<LEN(AFILE2EXT[PTRFILENAME][2]))

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC FUNCTION F_CurName()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
RETURN AFILE2EXT[PTRFILENAME][2][AFILE2EXT[PTRFILENAME][1]]

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE F_StepWait()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC cStep := "-\|/"

cStep := RIGHT(cStep,1)+LEFT(cStep,3)

@ maxrow()-7, 6 say LEFT(cStep,1) COLOR "Rb+/B"
@ maxrow()-7,73 say LEFT(cStep,1) COLOR "Rb+/B"

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE gauge(a,b)
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
dfPro(maxrow()-6,6,73,a,b,"G+/B")
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE f_saymsg(a,b)
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
DEVPOS(maxrow()-5,6)
DEVOUT(PADC(a,68),b)
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE f_say(a,b)
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
WHILE LEN(a)>0
   DISPBEGIN()
   SCROLL(4,7,maxrow()-16,72,1)
   DEVPOS( maxrow()-16,7)
   DEVOUT( PADR(a,66) ,b)
   DISPEND()
   a := SUBSTR(a,67)
ENDDO
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE writecurrent()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
DEVPOS(maxrow()-10,6)
DEVOUT(padc(dfToken(getcurrent(),";",1),68),"r+/B")
DEVPOS(maxrow()-9,6)
DEVOUT(padc(dfToken(getcurrent(),";",2),68),"r+/B")
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE f_saystatus(a)
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
DEVPOS(maxrow()-7, 6)
DEVOUT(padc(a,68),"Rb+/B")
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE F_DUMP_FILE( cFile, nHandle, nResOfs, cBitmap, nSize )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL nNewHandle := FCREATE( cFile )
LOCAL cBuff := SPACE(BUFLEN)
LOCAL nRead := 0, nAct

FSEEK( nHandle, nResOfs )
FWRITE( nNewHandle, cBitmap )
DO WHILE nRead<nSize
   nAct  := FREAD( nHandle, @cBuff, BUFLEN )
   nRead += nAct
   IF nSize<nRead
      nAct -= (nRead-nSize)
   ENDIF
   FWRITE( nNewHandle, LEFT( cBuff, nAct ) )
   IF nAct==0
      EXIT
   ENDIF
ENDDO

FCLOSE( nNewHandle )
LOCCOUNTER++
TOTCOUNTER++

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_ElabParam( patt )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL nTok, nCurTok, cLeft, nPos
IF left(patt,1) $ "/-" // ä un parametro
   DO CASE
      CASE upper(substr(patt,2,1)) == "P"
           EXTPATH := if(substr(patt,3,1)==":",substr(patt,4),substr(patt,3))

      CASE upper(substr(patt,2,1)) == "N"
           FCHECKMORE := .F.

      CASE upper(substr(patt,2,1)) == "B"
           FBATCH     := .T.
           FBATCHFAST := (upper(substr(patt,3,1)) == "+")

      CASE upper(substr(patt,2,1)) == "D" // log
           OUTDEBUG := 1
           IF upper(substr(patt,3,1)) == "+"
              OUTDEBUG := 2 // verbose
           ENDIF

      CASE upper(substr(patt,2,1)) == "R"
           RECOURSE := .T.

      CASE upper(substr(patt,2,4)) == "SAVE"
           HACKSTOPERASE := .F.

      CASE upper(substr(patt,2,1)) == "S"
           SKIPIFLIB := .T.

      CASE upper(substr(patt,2,1)) == "E"
           EXPAND := .T.

      CASE upper(substr(patt,2,1)) == "X"
           cLeft  := UPPER(ALLTRIM(SUBSTR(patt,3,3)))
           WHILE (nPos := ASCAN( ARRCHOICE, {|cStr|UPPER(ALLTRIM(SUBSTR(cStr,45,3)))==cLeft} ))>0
              ADEL( ARRCHOICE, nPos )
              ASIZE( ARRCHOICE, LEN(ARRCHOICE)-1 )
           ENDDO

      CASE upper(substr(patt,2,1)) == "I"
           IF LEN(ARRCHOICE)==LEN(MASTERFORMAT)
              ASIZE(ARRCHOICE,0)
           ENDIF
           FOR nPos := 1 TO LEN( MASTERFORMAT )
              cLeft := UPPER(ALLTRIM(SUBSTR(MASTERFORMAT[nPos],45,3)))
              IF cLeft==UPPER(ALLTRIM(SUBSTR(patt,3,3)))
                 AADD( ARRCHOICE, MASTERFORMAT[nPos] )
              ENDIF
           NEXT

      CASE upper(substr(patt,2,1)) == "G"
           GENERICDUMP := .T.

      CASE upper(substr(patt,2,2)) == "HS"
           DEHACKSTOP := .F.

      CASE upper(substr(patt,2,1)) $ "?H"
           bannerone()
           ? " Usage: MRIP [Filename[s]] [<Switches>] [@list]"
           set COLOR to

           IF upper(substr(patt,3,1)) $ "?"
              ?
              ? " You can specify multiple filenames, WildCards allowed!"
              ? " Ex.:   MRIP MYFILE?.* OTHER.DAT *.WAD"
              ?
              ? " This example shows how to extract from a CDROM in a batch process"
              ? "   MRIP /P:C:\RIPPED\MYFILES /D+ BIGFILE.HUG /B OTHER.DAT /F"
              ? " This example shows how to extract from a CDROM in a batch recourse process"
              ? "   MRIP /P:C:\RIPPED\MYFILES /D+ BIGFILE.HUG /B OTHER.DAT /F /R"
              ? " This example shows how to extract from a WINDOWS directory"
              ? "   MRIP C:\WINDOWS\*.* /B /R /S"
              ? " This example shows how to extract .EXE and .COM from a WINDOWS directory"
              ? "   MRIP C:\WINDOWS\*.COM C:\WINDOWS\*.EXE /B /R /S"
              ? " This example shows how to extract only bitmap from windows directory"
              ? "   MRIP C:\WINDOWS\*.* /IBMP /B /R /S"
           ELSE
              ?
              ? " /B[+]     = Perform a Batch scan without input [+ = No end pause]"
              ? " /D[+]     = Write MRIP.LOG [+ = Verbose output]"
              ? " /E        = Expand before scan"
              ? " /G        = Dump generic resource"
              ? " /HS+      = Don't use generic unpacking for ripping"
              ? " /N        = Do not perform checking on extracted files"
              ? " /P[:]path = Extraction Path, ':' is optional"
              ? " /R        = Recursive scan"
              ? " /SAVE     = Do not erase temp file of generic unpacker"
              ? " /S        = If file is a library, stop scan after lib extraction"
              ? " /X[FMT]   = Ignore FMT format. /XBMP ignore bitmap ripping"
              ? " /I[FMT]   = Include FMT format. /IBMP rip only bitmap"
              ? " /??       = Some example of use"
           ENDIF
           SET COLOR TO
           ? ""
           quit

      CASE upper(left(patt,2)) == "//"
           bannerone()
           ?"Yeah, right... Advanced Clipper User Detected... 8-)"
           SET COLOR TO
           ?
           ?"Don't mess with //Parameters here, they're not needed!"
           ?
           quit

      OTHERWISE
           bannerone()
           ?"Parameter error: ["+patt+"]"
           ?"Use MRIP /? for parameter syntax"
           SET COLOR TO
           ? ""
           quit

   ENDCASE
ELSE
   IF LEFT(patt,1)=="@"
      IF dfFOpen( SUBSTR(patt,2) )>0
         WHILE !dfFEof()
            patt := dfFRead()
            nTok := dfNumToken( patt, "  " )
            FOR nCurTok := 1 TO nTok
               F_ElabParam( ALLTRIM( dfToken(patt,"  ",nTok) ) )
            NEXT
            dfFSkip()
         ENDDO
         dfFClose()
      ENDIF
   ELSE
      IF !EMPTY(patt)
         AADD( FILEMASK, patt )
      ENDIF
   ENDIF
ENDIF
RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_ReadIni()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL cLine, lMain := .F., lUnpacker := .F., lPacker := .F., cLeft, cRight
LOCAL lFilter := .F., nPos, lResource, lDelphi := .F., lUser := .F.
LOCAL nPass := 0

IF dfFOpen( dfExePath()+"mrip.ini", FO_READ+FO_SHARED,,,.T.)>0
   WHILE !dfFEof()
      cLine := ALLTRIM(dfFRead())
      IF LEFT(cLine,1)=="["
         cLine := UPPER(cLine)
         lMain := lUnpacker := lPacker := lFilter := lResource := lDelphi := lUser := .F.
      ENDIF

      DO CASE
         CASE lMain
              cLeft := UPPER(dfLeft(cLine))
              DO CASE
                 CASE cLeft=="EXPANDPATH"
                      cRight := dfRight(cLine)
                      IF !EMPTY(cRight)
                         EXTPATH := cRight
                      ENDIF

                 CASE cLeft=="PERFORMCHECK"
                      FCHECKMORE := dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="STOPAFTERLIBRARY"
                      SKIPIFLIB := dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="BATCHSCAN"
                      FBATCH := dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="BATCHPAUSE"
                      FBATCHFAST := dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="RECOURSIVESCAN"
                      RECOURSE := dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="VERBOSE"
                      IF dfRight(cLine,RT_LOGICAL)
                         OUTDEBUG := 1
                      ENDIF

                 CASE cLeft=="VERBOSEEXTEND"
                      IF dfRight(cLine,RT_LOGICAL)
                         OUTDEBUG := 2
                      ENDIF

                 CASE cLeft=="EXPANDBEFORESCAN"
                      EXPAND := dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="DECRIPTHACKSTOP"
                      DEHACKSTOP := dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="DONTERASEFILE"
                      HACKSTOPERASE := !dfRight(cLine,RT_LOGICAL)

                 CASE cLeft=="GENERICRESOURCEDUMP"
                      GENERICDUMP := dfRight(cLine,RT_LOGICAL)

              ENDCASE

         CASE lUnpacker
              cLeft  := dfLeft(cLine)
              cRight := dfRight(cLine)
              IF FILE(dfToken( dfRight(cLine), " ", 1 ))
                 AADD( PACKLIST, { cLeft, cRight } )
              ENDIF

         CASE lPacker
              cLeft  := dfLeft(cLine)
              cRight := dfRight(cLine)
              AADD( FILELIST, { cLeft, cRight } )

         CASE lFilter
              cLeft  := UPPER(ALLTRIM(dfToken( cLine, " ", 1 )))
              WHILE (nPos := ASCAN( ARRCHOICE, {|cStr|UPPER(ALLTRIM(SUBSTR(cStr,45,3)))==cLeft} ))>0
                 ADEL( ARRCHOICE, nPos )
                 ASIZE( ARRCHOICE, LEN(ARRCHOICE)-1 )
              ENDDO

         CASE lResource
              cLeft  := UPPER(ALLTRIM(dfToken( cLine, " ", 1 )))
              AADD( ARESOURCE, cLeft )

         CASE lDelphi
              cLeft := UPPER(dfLeft(cLine))
              DO CASE
                 CASE cLeft=="VERBOSE"
                      DELPHIVERBOSE := dfRight(cLine,RT_LOGICAL)
                 CASE cLeft=="EXTRACTMETHODS"
                      DELPHIMETHODS := dfRight(cLine,RT_LOGICAL)
              ENDCASE

         CASE lUser
                 cRight := dfRight(cLine)
                 cLeft  := PADR(dfLeft(cLine),16)         +"≥" +;
                           PADR(dfToken(cRight,",",1),26) +"≥" +;
                           PADR(dfToken(cRight,",",2),3)  +"≥" +;
                                dfToken(cRight,",",3)

                 ASIZE( MASTERFORMAT, LEN(MASTERFORMAT)+1 )
                 AINS( MASTERFORMAT, LEN(MASTERFORMAT)-1 )
                 MASTERFORMAT[LEN(MASTERFORMAT)-1] := cLeft

                 ASIZE( ARRCHOICE, LEN(ARRCHOICE)+1 )
                 AINS( ARRCHOICE, LEN(ARRCHOICE)-1 )
                 ARRCHOICE[LEN(ARRCHOICE)-1] := cLeft

      ENDCASE

      DO CASE
         CASE cLine=="[MAIN]"     ;lMain     := .T.
         CASE cLine=="[UNPACKER]" ;lUnpacker := .T.
         CASE cLine=="[PACKER]"   ;lPacker   := .T.
         CASE cLine=="[FILTER]"   ;lFilter   := .T.
         CASE cLine=="[RESOURCE]" ;lResource := .T.
         CASE cLine=="[DELPHI]"   ;lDelphi   := .T.
         CASE cLine=="[USER]"     ;lUser     := .T.
      ENDCASE

      dfFSkip()
   ENDDO
   dfFClose()
ENDIF

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE F_Upd( cFile, cBuff )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL cDump := dfExePath()+"___mrip.exe"

IF !FILE( dfExePath() +cFile )
   MEMOWRIT( cDump, cBuff )
   IF FILE( cDump )
      F_SWPRUNCMD( cDump +" > NUL",0,dfExePath(),"")
      FERASE( cDump )
   ENDIF
ENDIF

RETURN

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION F_ExtName( cExt )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL cFile := "", nPos, nHandle

cExt := UPPER(ALLTRIM(cExt))
nPos := ASCAN( GENPATH, {|aFile|aFile[1]==cExt} )
IF nPos==0
   AADD( GENPATH, {cExt,0} )
   nPos := LEN(GENPATH)
ENDIF

WHILE .T.
   cFile := EXTPATH+cExt+PADL(GENPATH[nPos][2],8-LEN(cExt),"0")+"."+ALLTRIM(PADL(cExt,3))
   IF !FILE( cFile )
      nHandle := FCREATE( cFile )
      IF nHandle>0
         //GENPATH[nPos][2]++
         FCLOSE( nHandle )
         EXIT
      ELSE
         cFile := ""
         EXIT
      ENDIF
   ENDIF
   GENPATH[nPos][2]++
ENDDO

RETURN cFile

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION F_Fopen( cFile, nMode )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
RETURN FOPEN( cFile, nMode )

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
PROCEDURE F_CngFile()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL string, aDir2, aDir, nOpt, cFileToView :=""
LOCAL csc2 := savescreen(5,19,45,62)

NACTUAL := NOFFSET := 1
DISPBEGIN()
dfShade( 5, 19, 44, 60 )
@ 5, 19, 44, 61 BOX replicate( chr( 219 ), 8 ) + ' ' COLOR 'W+/B*'
aDir := DIRECTORY( "*.*" )
string := ' *.* '
@ 5, 40 - LEN( string ) / 2 SAY string COLOR 'W+/B'
aDir2 := {}
aEval( aDir, {| x | aadd( aDir2, PADR( UPPER( x[1] ), 12 ) + ' ' + ;
                                 PADL( STR( x[2] ), 10 )   + ' ' + ;
                                 DTOC( x[3] ) + ' ' + x[4] ) } )
DISPEND()
nOpt := dfWar( 6, 20, 43, 60, aDir2,.F.,"BG+/B","gr+/r" )
IF !EMPTY( nOpt )
   PARM := aDir[ nOpt ][1]
ENDIF
NACTUAL := NOFFSET := 1

restscreen(5,19,45,62,csc2 )

RETURN

/*
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_AssignBuff( nLen )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

BUFLEN    := MIN( MAX( 4096, nLen ), 32000 )
//  4096 == Minimo perche' i font a 16 bit lo richiedono
// 32768 == Massimo perche' le variabili clipper arrivano a 64,
//          ma oltre i 32 danno problemi passandole a funzioni C

BUFLEN := INT(BUFLEN/4)*4
// BUFLEN deve essere multiplo di 4 perche' la libreria coyote deve
// essere letta a gruppi di 4

RETURN
*/

/*
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
STATIC PROCEDURE F_SerType()
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

IF !EMPTY(SERIAL) .AND. !EMPTY(REGISTRATION)
   DO CASE
      CASE dfSerial2Key(SERIAL      ,MRIPPER_SHAREWARE) == REGISTRATION
           SERTYPE := MRIPPER_SHAREWARE

      CASE dfSerial2Key(SERIAL      ,MRIPPER_STANDARD ) == REGISTRATION
           SERTYPE := MRIPPER_STANDARD

      CASE dfSerial2Key(SERIAL      ,MRIPPER_GOLD     ) == REGISTRATION
           SERTYPE := MRIPPER_GOLD

   ENDCASE
ENDIF

RETURN
*/
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION F_Inkey( n )
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL nRet
IF n==NIL
   nRet := INKEY()
ELSE
   nRet := INKEY(n)
ENDIF
RETURN nRet

* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
FUNCTION F_SWPRUNCMD(a,b,c,d)
* ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
LOCAL nRet

// Messo per problemi 4dos
setcursor(1)
setcursor(0)

nRet := SWPRUNCMD(a,b,c,d)

// Messo per problemi 4dos
setcursor(1)
setcursor(0)

RETURN nRet
